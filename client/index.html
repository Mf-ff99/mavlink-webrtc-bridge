<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>WebRTC Data Channel Example</title>
    <!-- <styles src="/styles.css"></styles> -->
    <link rel="stylesheet" href="./styles.css">
    <!-- styles and script src for maps -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""/>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""></script>
    <!-- <script src="./mapView.js"></script> -->
    <script>
        let pc
        let ws
        var map
        // isConnected flag
        var isConnected = false

        // attitude indicator
        var canvas, ctx, width, height, centerX, centerY, horizonLine

        function disconnect_pc(pc) {
            pc.close()
            console.log('connection closed')
        }

        document.addEventListener('DOMContentLoaded', function() {
            canvas = document.getElementById('attitude');
            ctx = canvas.getContext('2d');
            width = canvas.width;
            height = canvas.height;
            centerX = width / 2;
            centerY = height / 2;
            horizonLine = centerY;
        })

        // STUN/TURN configuration
        const config = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' }
            ]
        }

        // updateMap(48.52435, 13.63872)

        // draw map
        function createMap() {
            map = L.map('map').setView([26.79478, -5.91295], 8)
    
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map)
        }

        function updateMap(lat, long) {
            if (!map) {
                console.error('Map is not initialized.');
                return;
            }

            map.eachLayer(function(layer) {
                if (layer instanceof L.Marker) {
                    map.removeLayer(layer);
                }
            })

            L.marker([lat, long]).addTo(map)
                .bindPopup('Drone Location').openPopup();

            map.panTo(new L.LatLng(lat, long));
        }

        // attitude canvas
        function drawAttitude(roll, pitch) {
            if(!ctx) return
            ctx.clearRect(0, 0, width, height);  // Clear the canvas

            ctx.beginPath()
            ctx.arc(centerX, centerY, Math.min(centerX, centerY), 0, 2 * Math.PI)
            ctx.clip()

            const pitchPixelShift = pitch * 5
            const horizonY = centerY + pitchPixelShift  // Positive pitch moves horizon up, negative moves it down

            ctx.fillStyle = 'skyblue'
            ctx.fillRect(0, 0, width, horizonY)  

            ctx.fillStyle = 'saddlebrown'
            ctx.fillRect(0, horizonY, width, height * 2)
            // Save context for rotation
            ctx.save()
            ctx.translate(centerX, centerY)
            ctx.rotate(roll * Math.PI / 180)
            ctx.translate(-centerX, -centerY)

            // Draw the horizon line
            ctx.strokeStyle = 'white'
            ctx.lineWidth = 2
            ctx.beginPath()
            ctx.moveTo(0, centerY)
            ctx.lineTo(width, centerY)
            ctx.stroke()

            ctx.restore()

            ctx.beginPath()
            ctx.lineWidth = 3
            ctx.moveTo(centerX - 10, centerY)
            ctx.lineTo(centerX + 10, centerY)
            // ctx.moveTo(centerX, centerY - 10)
            // ctx.lineTo(centerX, centerY + 10)
            ctx.strokeStyle = 'red'
            ctx.stroke()

            ctx.strokeStyle = '#d4d4d4'
            ctx.lineWidth = 10
            ctx.beginPath()
            ctx.arc(centerX, centerY, Math.min(centerX, centerY) - 5, 0, 2 * Math.PI)
            ctx.stroke()
            
        }
                    

        async function createPeerConnection() {
            pc = new RTCPeerConnection(config)

            const dataChannel = pc.createDataChannel("telemetry")

            pc.addTransceiver('video')

            pc.ontrack = function(e) {
                console.log('Received track:', e.track)
                console.log('Associated streams:', e.streams)

                if (e.streams && e.streams[0]) {
                    var videoElement = document.getElementById('video')
                    if (videoElement) {
                        videoElement.srcObject = e.streams[0]
                        console.log('Video source object set.')
                    } else {
                        console.error('Video element not found!')
                    }
                } else {
                    console.error('No streams available on the event!')
                }
            }

            dataChannel.onopen = () => {
                console.log("Data channel opened.")
                const disconnectButton = document.getElementById('disconnectButton')
                disconnectButton.disabled = false
            }
            dataChannel.onclose = () => {
                console.log("Data channel closed.")
                isConnected = false
            }

            dataChannel.onmessage = e => {
                const data = e.data.match(/-?\d+\.\d+/g).map(Number)
                const [yaw, pitch, roll, latitude, longitude, altitude] = data

                // console.log(data)

                updateIndicators(pitch, roll, yaw)
                drawAttitude(roll, pitch)
                isConnected = true      
            }
            pc.onicecandidate = event => {
                if (event.candidate) {
                    console.log('ICE candidate:', event.candidate)
                    if (event.candidate) {
                        ws.send(JSON.stringify({
                            'candidate': {
                                foundation: event.candidate.foundation,
                                ip: event.candidate.address,
                                port: event.candidate.port,
                                priority: event.candidate.priority,
                                protocol: event.candidate.protocol,
                                component: 1,
                                sdpMid: event.candidate.sdpMid,
                                sdpMLineIndex: event.candidate.sdpMLineIndex,
                                type: event.candidate.type,
                            }
                        }))
                    }
                }            // updateMap(48.52435, 13.63872)

            }

            const offer = await pc.createOffer()
            await pc.setLocalDescription(offer)
            ws.send(JSON.stringify({ 'sdp': pc.localDescription }))
        }

        function startWebSocket() {
            const disconnectButton = document.getElementById('connectButton')
            const connectButton = document.getElementById('connectButton')

            ws = new WebSocket('ws://localhost:8765')
            ws.onopen = () => {
                console.log('WebSocket connected')
                createPeerConnection()
            }
            ws.onmessage = async event => {
                const data = JSON.parse(event.data)
                if (data.sdp) {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.sdp))
                } else if (data.candidate) {
                    await pc.addIceCandidate(new RTCIceCandidate(data.candidate))
                }
            }
            ws.onclose = () => {
                connectButton.disabled = false
            }
        }
        
        function updateIndicators(pitch, roll, yaw) {
            const pitchElement = document.getElementById('pitch')
            const rollElement = document.getElementById('roll')
            const yawElement = document.getElementById('yaw')

            pitchElement.textContent = `Pitch: ${pitch}°`
            rollElement.textContent = `Roll: ${roll}°`
            yawElement.textContent = `Yaw: ${yaw}°`
        }

        document.addEventListener('DOMContentLoaded', () => {
            const connectButton = document.getElementById('connectButton');
            const disconnectButton = document.getElementById('disconnectButton')

            // create map after DOM is loaded
            createMap()

            connectButton.addEventListener('click', async function() {
                    if (!isConnected) {
                        startWebSocket()
                        connectButton.disabled = true
                    }
                })

            disconnectButton.addEventListener('click', async function() {
                if (isConnected) {
                    pc.close()
                    connectButton.disabled = false
                    disconnectButton.disabled = true
                }
            })
        })

            

    </script>
</head>

<body>
    <nav class="navbar navbar-expand-lg navbar-light bg-light justify-content-between">
        <h2>Command Center</h2>
        <div class="connectButtonContainer">
            <button id="connectButton">Connect</button>
            <button id="disconnectButton" disabled>Disconnect</button>
        </div>
    </nav>

    <div class="connectedView">
        
        <div class="mapView">
            <div id="map" class="map"></div>
        </div>

        <div class="droneView">
            
            <div class="indicator-container">
                <div class="indicator" id="pitch">Pitch: 0°</div>
                <div class="indicator" id="roll">Roll: 0°</div>
                <div class="indicator" id="yaw">Yaw: 0°</div>
            </div>
            
            <div class="attitude-indicator">
                <canvas id="attitude" width="300" height="300"></canvas>
            </div>
            
            <video id="video" autoplay controls></video>
    
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
</body>