<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>WebRTC Data Channel Example</title>
    <styles src="./styles.css"></styles>
    <script>
        let pc
        let ws

        // isConnected
        var isConnected = false

        // attitude indicator
        var canvas, ctx, width, height, centerX, centerY, horizonLine

        document.addEventListener('DOMContentLoaded', function() {
            canvas = document.getElementById('attitude');
            ctx = canvas.getContext('2d');
            width = canvas.width;
            height = canvas.height;
            centerX = width / 2;
            centerY = height / 2;
            horizonLine = centerY;
        });

        // attitude canvas
        function drawAttitude(roll, pitch) {
            if(!ctx) return
            ctx.clearRect(0, 0, width, height);  // Clear the canvas

            ctx.beginPath()
            ctx.arc(centerX, centerY, Math.min(centerX, centerY), 0, 2 * Math.PI)
            ctx.clip()

            const pitchPixelShift = pitch * 5
            const horizonY = centerY + pitchPixelShift  // Positive pitch moves horizon up, negative moves it down

            ctx.fillStyle = 'skyblue'
            ctx.fillRect(0, 0, width, horizonY)  

            ctx.fillStyle = 'saddlebrown'
            ctx.fillRect(0, horizonY, width, height * 2)
            // Save context for rotation
            ctx.save()
            ctx.translate(centerX, centerY)
            ctx.rotate(roll * Math.PI / 180)
            ctx.translate(-centerX, -centerY)

            // Draw the horizon line
            ctx.strokeStyle = 'white'
            ctx.lineWidth = 2
            ctx.beginPath()
            ctx.moveTo(0, centerY)
            ctx.lineTo(width, centerY)
            ctx.stroke()

            ctx.restore()

            ctx.beginPath()
            ctx.lineWidth = 3
            ctx.moveTo(centerX - 10, centerY)
            ctx.lineTo(centerX + 10, centerY)
            // ctx.moveTo(centerX, centerY - 10)
            // ctx.lineTo(centerX, centerY + 10)
            ctx.strokeStyle = 'red'
            ctx.stroke()

            ctx.strokeStyle = '#d4d4d4'
            ctx.lineWidth = 10
            ctx.beginPath()
            ctx.arc(centerX, centerY, Math.min(centerX, centerY) - 5, 0, 2 * Math.PI)
            ctx.stroke()
                    }

            // STUN/TURN configuration
            const config = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' }
                ]
        }

        async function createPeerConnection() {
            pc = new RTCPeerConnection(config)

            const dataChannel = pc.createDataChannel("telemetry")

            pc.addTransceiver('video')

            pc.ontrack = function(e) {
                console.log('Received track:', e.track)
                console.log('Associated streams:', e.streams)

                if (e.streams && e.streams[0]) {
                    var videoElement = document.getElementById('video')
                    if (videoElement) {
                        videoElement.srcObject = e.streams[0]
                        console.log('Video source object set.')
                    } else {
                        console.error('Video element not found!')
                    }
                } else {
                    console.error('No streams available on the event!')
                }
            }

            dataChannel.onopen = () => {
                console.log("Data channel opened.")
            }
            dataChannel.onclose = () => {
                console.log("Data channel closed.")
                isConnected = false
            }
            dataChannel.onmessage = e => {
                const [yaw, pitch, roll] = e.data.match(/-?\d+\.\d+/g).map(Number)
                updateIndicators(pitch, roll, yaw)
                drawAttitude(roll, pitch)
                isConnected = true
            }
            pc.onicecandidate = event => {
                if (event.candidate) {
                    console.log('ICE candidate:', event.candidate)
                    if (event.candidate) {
                        ws.send(JSON.stringify({
                            'candidate': {
                                foundation: event.candidate.foundation,
                                ip: event.candidate.address,
                                port: event.candidate.port,
                                priority: event.candidate.priority,
                                protocol: event.candidate.protocol,
                                component: 1,
                                sdpMid: event.candidate.sdpMid,
                                sdpMLineIndex: event.candidate.sdpMLineIndex,
                                type: event.candidate.type,
                            }
                        }))
                    }
                }
            }

            const offer = await pc.createOffer()
            await pc.setLocalDescription(offer)
            ws.send(JSON.stringify({ 'sdp': pc.localDescription }))
        }

        function startWebSocket() {
            ws = new WebSocket('ws://localhost:8765')
            ws.onopen = () => {
                const connectButton = document.getElementById('connectButton')
                if (isConnected) {
                        connectButton.disabled = true;
                    }
                console.log('WebSocket connected')
                createPeerConnection()
            }
            ws.onmessage = async event => {
                const data = JSON.parse(event.data)
                if (data.sdp) {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.sdp))
                } else if (data.candidate) {
                    await pc.addIceCandidate(new RTCIceCandidate(data.candidate))
                }
            }
        }
        
        function updateIndicators(pitch, roll, yaw) {
            const pitchElement = document.getElementById('pitch')
            const rollElement = document.getElementById('roll')
            const yawElement = document.getElementById('yaw')

            pitchElement.textContent = `Pitch: ${pitch}°`
            rollElement.textContent = `Roll: ${roll}°`
            yawElement.textContent = `Yaw: ${yaw}°`
        }

        document.addEventListener('DOMContentLoaded', () => {
            const connectButton = document.getElementById('connectButton');

            connectButton.addEventListener('click', async function() {
                    if (!isConnected) {
                        startWebSocket()
                        connectButton.disabled = true
                    }
                });
            });        

        // window.onload = startWebSocket
    </script>
</head>

<body>
    <nav>
        <h2>Telemetry Data</h2>
        <button id="connectButton">Connect!</button>
    </nav>
        <div class="indicator-container">
            <div class="indicator" id="pitch">Pitch: 0°</div>
            <div class="indicator" id="roll">Roll: 0°</div>
            <div class="indicator" id="yaw">Yaw: 0°</div>
        </div>

        <div class="attitude-indicator">
            <canvas id="attitude" width="300" height="300"></canvas>
        </div>

        <video id="video" autoplay controls>

        </video>
</body>